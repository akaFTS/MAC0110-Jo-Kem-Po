% abrimos a imagem e enviamos para o método corretofunction decompress (compressedImg, method, k)        imraw = imread(compressedImg);        imraw = double(imraw);        if method == 1                newImg = bilinearDecompress (imraw, k);        end                %escrevemos a imagem final        imwrite(newImg, "decompressed.png");end% interpolador bilinearfunction newImg = bilinearDecompress (imraw, k)        h = 1;        n = size(imraw, 1);                % podemos supor sem nenhum problema que estamos trabalhando        % com vários quadrados cujos vértices (0,0), (0,1), (1,0), (1,1) são conhecidos        % isso simplifica grandiosamente a fórmula da interpolação para isto:        % f(x,y) = f(0,0)*(1-x)*(1-y) + f(1,0)*x*(1-y) + f(0,1)*(1-x)*y + f(1,1)*x*y                % para fazer esta mágica, vamos criar matrizes que vão guardar os valores        % de f(0,0), f(0,1), f(1,0), f(1,1) em cada ponto da imagem interpolada.        % é como se pegássemos uma matriz (n-1)x(n-1) dentro da matriz imagem nxn.        % para f(0,0), ignoramos a ultima linha e coluna para formar esta matriz, pois o ponto        % 0,0 é sempre o que está na diagonal superior esquerda. Para f(0,1) ignoramos a primeira linha        % e a última coluna, pois é o que está na diagonal inferior esquerda, e por ai vai.        % depois, temos que expandir essa matriz inserindo as k linhas e colunas entre        % cada linha, e guardando os valores dos vértices do quadrado para esses novos pontos.                %{ Um exemplo pra facilitar o entendimento:                1 5 7        3 2 4 --- é a imagem original        6 9 8                1 0 5 0 7        0 0 0 0 0        3 0 2 0 4 --- é a futura imagem final        0 0 0 0 0        6 0 9 0 8                Para aquele ponto na segunda linha da segunda coluna, f(0,0) é 1, f(1,0) é 5, f(0,1) é 3 e f(1,1) é 4.        A mesma coisa vale pros pontos vazios no entorno dele, mas no caso deles, como estão na fronteira        entre quadrados, podemos escolher a qual pertencem. Pra facilitar, vamos fazer assim:                1 1 5 5 5        1 1 5 5 5        3 3 2 2 2 -- é a matriz com o f(0,0) de cada ponto, inclusive dos pontos existentes (daria muito trabalho separar eles)        3 3 2 2 2        3 3 2 2 2                A terceira fileira poderia ser 1 1 5 5 5 sem problema, é uma decisão de projeto e é o mais simples de fazer com MATLAB.        A última fileira de pixels conhecidos foi ignorada, pois ela não é f(0,0) de ninguém. Na verdade, o 7 poderia ser f(0,0)        do 0 logo abaixo dele, mas ele teria problemas com os outros três indices. Por isso, relacionamos tudo com o pixel anterior.                2 2 4 4 4        2 2 4 4 4        9 9 8 8 8  -- é a matriz dos f(1,1). Já deu pra pegar a ideia.        9 9 8 8 8        9 9 8 8 8                %}                % estas variáveis top e bottom vão ajudar a fazer as duas coisas. Top vai ignorar a última linha/coluna        % e replicar as outras k+1 vezes. A penúltima linha/coluna vai ser replicada k+2 vezes. Como não dá        % pra fazer isso numa tacada só, replicamos todas k+1 vezes e a última uma vez e depois trocamos a última na marra        % a variável bottom faz a mesma coisa, só que ignorando a primeira.        top = floor(1: 1/(k+1): n);        top(end) = n-1;        bottom = ceil(1: 1/(k+1): n);        bottom(1) = [];        bottom(end+1) = n;                ns = size(top, 2);                        % na realidade, top e bottom só geram um conjunto de índices (por exemplo, [1 1 2 2 3 3 3])        % a mágica real acontece aqui. Vamos pegar esses índices direto da imagem original para construir        % nossos filtros de cada vértice do quadrado, já no tamanho da imagem final.        f00 = imraw(top, top, :);        f10 = imraw(top, bottom, :);        f01 = imraw(bottom, top, :);        f11 = imraw(bottom, bottom, :);                %{                Como assumimos que nossos pixels existentes formam quadrados de lado 1, todos os pixels        novos devem assumir valores entre 0 e 1. Vamos criar duas matrizes, uma com a coordenada x de cada        pixel (inclusive os conhecidos) e outra com a y.                 Voltando no nosso exemplo:                1 0 5 0 7        0 0 0 0 0        3 0 2 0 4        0 0 0 0 0        6 0 9 0 8                A nossa matriz de posição X ficaria:                0 0.5 0 0.5 1        0 0.5 0 0.5 1        0 0.5 0 0.5 1 ----- e a matriz de y é a transposta desta.        0 0.5 0 0.5 1        0 0.5 0 0.5 1                Repare que os pixels conhecidos são sempre 0 ou 1, pois são os vértices do quadrado. No caso, como lá        em cima decidimos que os caras da terceira fileira pertencem ao quadrado do f(0,0) = 5 e não do f(0,0) = 1,        então eles possuem coordenada 0, pois estão no canto esquerdo do quadrado. Já os caras da última linha, como        fazem parte do quadrado formado por 5, 7, 2 e 4 (como dito acima, já que se usássemos o 7 como f(0,0) ficaríamos        sem ninguém para escolher para formar a margem direita do quadrado) então o índice deles é 1, pois estão no lado        direito do quadrado.                Na prática, toda coluna com pixels conhecidos é 0, as outras colunas vão andando a passo de 1/(k+1), e a última é 1.        O mesmo raciocínio serve pro Y.         A maior complicação mesmo é o malabarismo do MATLAB pra fazer isso de um modo eficiente pra matrizes gigantes.                %}                % agora queremos matrizes de índices, do tamanho da imagem final.        % os pixels existentes vão ter índice 0 ou 1 (afinal, é um quadrado unitário). Os novos pixels        % vão ser distribuídos nesse intervalo igualmente espaçados.        gen = 0: 1/(k+1): 1;        gen = gen(mod(0: (ns - 2), k+1) + 1);        gen(end+1) = 1;                % tudo isso é mágica do MATLAB pra construir essas matrizes de modo eficiente        x = gen(ones(ns, 1), :);        y = gen'(:, ones(ns, 1));                % agora que temos a coordenada X e Y de cada ponto, e os valores de F nos vértices do quadrado        % relacionado a cada ponto, é só fazer a conta que a imagem inteira fica pronta em uma tacada só.        newMat = f00.*(1 - x).*(1 - y) + f10.*x.*(1 - y) + f01.*(1 - x).*y + f11.*x.*y;                newImg = uint8(newMat);end