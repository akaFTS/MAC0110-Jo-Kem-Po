% abrimos a imagem e enviamos para o método corretofunction decompress (compressedImg, method, k)        imraw = imread(compressedImg);        imraw = double(imraw);        tic        if method == 1                newImg = bilinearDecompress (imraw, k);        else                newImg = bicubicDecompress (imraw, k);        end        toc        %escrevemos a imagem final        imwrite(newImg, "decompressed.png");end% interpolador bilinearfunction newImg = bilinearDecompress (imraw, k)        n = size(imraw, 1);                % podemos supor sem nenhum problema que estamos trabalhando        % com vários quadrados cujos vértices (0,0), (0,1), (1,0), (1,1) são conhecidos        % isso simplifica grandiosamente a fórmula da interpolação para isto:        % f(x,y) = f(0,0)*(1-x)*(1-y) + f(1,0)*x*(1-y) + f(0,1)*(1-x)*y + f(1,1)*x*y                % para fazer esta mágica, vamos criar matrizes que vão guardar os valores        % de f(0,0), f(0,1), f(1,0), f(1,1) em cada ponto da imagem interpolada.        % é como se pegássemos uma matriz (n-1)x(n-1) dentro da matriz imagem nxn.        % para f(0,0), ignoramos a ultima linha e coluna para formar esta matriz, pois o ponto        % 0,0 é sempre o que está na diagonal superior esquerda. Para f(0,1) ignoramos a primeira linha        % e a última coluna, pois é o que está na diagonal inferior esquerda, e por ai vai.        % depois, temos que expandir essa matriz inserindo as k linhas e colunas entre        % cada linha, e guardando os valores dos vértices do quadrado para esses novos pontos.                % Um exemplo pra facilitar o entendimento:                % 1 5 7        % 3 2 4 --- é a imagem original        % 6 9 8                % 1 0 5 0 7        % 0 0 0 0 0        % 3 0 2 0 4 --- é a futura imagem final        % 0 0 0 0 0        % 6 0 9 0 8                % Para aquele ponto na segunda linha da segunda coluna, f(0,0) é 1, f(1,0) é 5, f(0,1) é 3 e f(1,1) é 4.        % A mesma coisa vale pros pontos vazios no entorno dele, mas no caso deles, como estão na fronteira        % entre quadrados, podemos escolher a qual pertencem. Pra facilitar, vamos fazer assim:                % 1 1 5 5 5        % 1 1 5 5 5        % 3 3 2 2 2 -- é a matriz com o f(0,0) de cada ponto, inclusive dos pontos existentes (daria muito trabalho separar eles)        % 3 3 2 2 2        % 3 3 2 2 2                % A terceira fileira poderia ser 1 1 5 5 5 sem problema, é uma decisão de projeto e é o mais simples de fazer com MATLAB.        % A última fileira de pixels conhecidos foi ignorada, pois ela não é f(0,0) de ninguém. Na verdade, o 7 poderia ser f(0,0)        % do 0 logo abaixo dele, mas ele teria problemas com os outros três indices. Por isso, relacionamos tudo com o pixel anterior.                % 2 2 4 4 4        % 2 2 4 4 4        % 9 9 8 8 8  -- é a matriz dos f(1,1). Já deu pra pegar a ideia.        % 9 9 8 8 8        % 9 9 8 8 8                        % estas variáveis top e bottom vão ajudar a fazer as duas coisas. Top vai ignorar a última linha/coluna        % e replicar as outras k+1 vezes. A penúltima linha/coluna vai ser replicada k+2 vezes. Como não dá        % pra fazer isso numa tacada só, replicamos todas k+1 vezes e a última uma vez e depois trocamos a última na marra        % a variável bottom faz a mesma coisa, só que ignorando a primeira.        top = floor(1: 1/(k+1): n);        top(end) = n-1;        bottom = ceil(1: 1/(k+1): n);        bottom(1) = [];        bottom(end+1) = n;                ns = size(top, 2);                        % na realidade, top e bottom só geram um conjunto de índices (por exemplo, [1 1 2 2 3 3 3])        % a mágica real acontece aqui. Vamos pegar esses índices direto da imagem original para construir        % nossos filtros de cada vértice do quadrado, já no tamanho da imagem final.        f00 = imraw(top, top, :);        f10 = imraw(top, bottom, :);        f01 = imraw(bottom, top, :);        f11 = imraw(bottom, bottom, :);                        % Como assumimos que nossos pixels existentes formam quadrados de lado 1, todos os pixels        % novos devem assumir valores entre 0 e 1. Vamos criar duas matrizes, uma com a coordenada x de cada        % pixel (inclusive os conhecidos) e outra com a y.                 % Voltando no nosso exemplo:                % 1 0 5 0 7        % 0 0 0 0 0        % 3 0 2 0 4        % 0 0 0 0 0        % 6 0 9 0 8                % A nossa matriz de posição X ficaria:                % 0 0.5 0 0.5 1        % 0 0.5 0 0.5 1        % 0 0.5 0 0.5 1 ----- e a matriz de y é a transposta desta.        % 0 0.5 0 0.5 1        % 0 0.5 0 0.5 1                % Repare que os pixels conhecidos são sempre 0 ou 1, pois são os vértices do quadrado. No caso, como lá        % em cima decidimos que os caras da terceira fileira pertencem ao quadrado do f(0,0) = 5 e não do f(0,0) = 1,        % então eles possuem coordenada 0, pois estão no canto esquerdo do quadrado. Já os caras da última linha, como        % fazem parte do quadrado formado por 5, 7, 2 e 4 (como dito acima, já que se usássemos o 7 como f(0,0) ficaríamos        % sem ninguém para escolher para formar a margem direita do quadrado) então o índice deles é 1, pois estão no lado        % direito do quadrado.                % Na prática, toda coluna com pixels conhecidos é 0, as outras colunas vão andando a passo de 1/(k+1), e a última é 1.        % O mesmo raciocínio serve pro Y.         % A maior complicação mesmo é o malabarismo do MATLAB pra fazer isso de um modo eficiente pra matrizes gigantes.                        % agora queremos matrizes de índices, do tamanho da imagem final.        % os pixels existentes vão ter índice 0 ou 1 (afinal, é um quadrado unitário). Os novos pixels        % vão ser distribuídos nesse intervalo igualmente espaçados.        gen = 0: 1/(k+1): 1;        gen = gen(mod(0: (ns - 2), k+1) + 1);        gen(end+1) = 1;                % tudo isso é mágica do MATLAB pra construir essas matrizes de modo eficiente        x = gen(ones(ns, 1), :);        y = gen'(:, ones(ns, 1));                % agora que temos a coordenada X e Y de cada ponto, e os valores de F nos vértices do quadrado        % relacionado a cada ponto, é só fazer a conta que a imagem inteira fica pronta em uma tacada só.        newMat = f00.*(1 - x).*(1 - y) + f10.*x.*(1 - y) + f01.*(1 - x).*y + f11.*x.*y;                newImg = uint8(newMat);endfunction newImg = bicubicDecompress(imraw, k)        h = 1;        n = size(imraw, 1);        ns = n + (n-1)*k;        newMat = zeros(ns, ns, 3);                % matrizes X e Y, guardando as coordenadas dos novos pontos        % entre 0 e h (que são as coordenadas dos pixels conhecidos)        X = h * [0: 1/(k+1): 1]';        X = [(X.^0) X (X.^2) (X.^3)];        Y = X';                % matriz B        B = [1 0 0 0; 0 0 1 0; -3/(h^2) 3/(h^2) -2/h -1/h; 2/(h^3) -2/(h^3) h^(-2) h^(-2)];                % fazemos uma moldura na matriz repetindo a primeira e ultima linhas/colunas duas vezes        % como nossa derivada usa dados do ponto anterior e do próximo, exigiria tratamento        % nas bordas da imagem. Com essa moldura, podemos agir normalmente        framed = [imraw(1, :, :); imraw; imraw(end, :, :)];        framed = [framed(:, 1, :) framed framed(:, end, :)];                % vamos varrer cada pixel conhecido e trabalhar no quadrado        % de lado h em que ele é o canto superior esquerdo        % por esse mesmo motivo, os pixels da borda direita e da borda inferior        % não serão varridos        % lembrando que estamos numa matriz com borda de tamanho 1, por isso ir de 2:n        % equivale a ir de 1:n-1 na matriz real        for i = 2:n                for j = 2:n                                        % valores dos vertices                        f00 = framed(i, j, :);                        f01 = framed(i, j+1, :);                        f10 = framed(i+1, j, :);                        f11 = framed(i+1, j+1, :);                                                % valores auxiliares                        fZ0 = framed(i-1, j, :);                        f0Z = framed(i, j-1, :);                        fZ1 = framed(i-1, j+1, :);                        f1Z = framed(i+1, j-1, :);                        fZZ = framed(i-1, j-1, :);                                                f20 = framed(i+2, j, :);                        f02 = framed(i, j+2, :);                        f21 = framed(i+2, j+1, :);                        f12 = framed(i+1, j+2, :);                        f22 = framed(i+2, j+2, :);                                                f2Z = framed(i+2, j-1, :);                        fZ2 = framed(i-1, j+2, :);                                                                        % derivadas parciais                        fx00 = (f10 - fZ0)/(2*h);                        fx01 = (f11 - fZ1)/(2*h);                                                fx10 = (f20 - f00)/(2*h);                        fx11 = (f21 - f01)/(2*h);                                                fy00 = (f01 - f0Z)/(2*h);                        fy01 = (f02 - f00)/(2*h);                        fy10 = (f11 - f1Z)/(2*h);                        fy11 = (f12 - f10)/(2*h);                                                % parciais auxiliares                        fyZ0 = (fZ1 - fZZ)/(2*h);                        fyZ1 = (fZ2 - fZ0)/(2*h);                        fy20 = (f21 - f2Z)/(2*h);                        fy21 = (f22 - f20)/(2*h);                                                % derivadas mistas                        fxy00 = (fy10 - fyZ0)/(2*h);                        fxy01 = (fy11 - fyZ1)/(2*h);                        fxy10 = (fy20 - fy00)/(2*h);                        fxy11 = (fy21 - fy01)/(2*h);                                                % montamos a matriz e fazemos a conta                        funcs = [f00   f01   fy00   fy01;                                       f10   f11   fy10   fy11;                                       fx00 fx01 fxy00 fxy01;                                       fx10 fx11 fxy10 fxy11];                                                %precisa ser multiplicado separadamente para cada camada de cor                        coefs(:, :, 1) = B * funcs(:, :, 1) * B';                        coefs(:, :, 2) = B * funcs(:, :, 2) * B';                        coefs(:, :, 3) = B * funcs(:, :, 3) * B';                                                                        % interpolamos todos os pontos                        V(:, :, 1) = X * coefs(:, :, 1) * Y;                        V(:, :, 2) = X * coefs(:, :, 2) * Y;                        V(:, :, 3) = X * coefs(:, :, 3) * Y;                                                % adicionamos o quadrado que interpolamos no canvas newMat que                        % formará a imagem interpolada no final                        starti = (i-2)*(k+1) + 1;                        startj = (j-2)*(k+1) + 1;                        endi =  (i-1)*(k+1) + 1;                        endj =  (j-1)*(k+1) + 1;                        newMat(starti:endi, startj:endj, :) = V;                                        end        end                % convertemos nossa matriz para uma matriz de inteiros positivos 8-bits,         % que é o padrão pedido para imagens        newImg = uint8(newMat);end